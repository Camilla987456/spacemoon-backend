package login

import (
	"net/http"
	"strings"
)


// NewProtector instantiates a new protector. It should point to the same persistence as the login handler
// created with the NewHandler function. The protector and login handler work together to create
// temporary tokens for any UserName and Password. This avoids sending the basic login information
// on most protected calls and allows the system to still authenticate and identify the requesting user.
func NewProtector(p Persistence) Protector {
	return protector{persistence: p}
}

// ProtectedHandler is a decorator for a handler, that allow selective authentication on certain methods, by using
// the bearer token generated by the login handler
type ProtectedHandler interface {
	http.Handler
	// Unprotect allows a specific method of the handler to be used without protection
	Unprotect(method string)
}

// Protector is charged of protecting a handler by creating a decorator handler that checks for a valid token from 
// the persistence used by the login http.Handler (that you can retrieve using the NewHandler function) to save 
// active bearer token information 
type Protector interface {
	Protect(*http.Handler) ProtectedHandler
}

type protector struct {
	persistence Persistence
}

// Protect creates a decorator handler that requires a valid and active Token to allow the protected handler to be 
// used only by authenticated users or only on Unprotected methods.  
func (p protector) Protect(h *http.Handler) ProtectedHandler {
	return &protected{handler: h, persistence: p.persistence}
}

type protected struct {
	handler            *http.Handler
	persistence        Persistence
	unprotectedMethods []string
}

func (p *protected) Unprotect(httpMethod string) {
	p.unprotectedMethods = append(p.unprotectedMethods, httpMethod)
}

func (p *protected) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	protectedHandler := *p.handler
	if contains(p.unprotectedMethods, r.Method) {
		protectedHandler.ServeHTTP(w, r)
		return
	}
	bearer := r.Header.Get("Authorization")
	if p.validateToken(w, bearer) {
		return
	}
	protectedHandler.ServeHTTP(w, r)
}

func (p *protected) validateToken(w http.ResponseWriter, bearer string) bool {
	if validateBearerTokenPresence(w, bearer) {
		return true
	}
	token := extractToken(bearer)
	_, err := p.getUserFromToken(w, token)
	if err != nil {
		return true
	}
	return false
}

func (p *protected) getUserFromToken(w http.ResponseWriter, token Token) (UserName, error) {
	u, err := p.persistence.GetUser(token)
	if err != nil {
		w.WriteHeader(http.StatusForbidden)
		_, _ = w.Write([]byte(err.Error()))
		return "", err
	}
	return u, nil
}

func validateBearerTokenPresence(w http.ResponseWriter, bearer string) bool {
	if strings.TrimSpace(bearer) == "" {
		w.WriteHeader(http.StatusUnauthorized)
		_, _ = w.Write([]byte("no bearer token"))
		return true
	}
	return false
}

func extractToken(bearer string) Token {
	return Token(strings.TrimPrefix(bearer, "Bearer "))
}

func contains(methods []string, method string) bool {
	for _, m := range methods {
		if method == m {
			return true
		}
	}
	return false
}
